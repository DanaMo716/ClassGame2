<!doctype html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ù„Ø¹Ø¨Ø© ØµÙŠØ§Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª - ØªØ¹Ù„Ù‘Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</title>
    <style>
         :root {
            --bg: #f9f7f5;
            --card: #ffffff;
            --ink: #222;
            --muted: #666;
            --accent: #ff7043;
            --ok: #4caf50;
            --bad: #f44336;
            --shadow: 0 8px 20px rgba(0, 0, 0, .08);
            --cell: 38px;
            /* ğŸ‘ˆ ÙƒØ¨Ù‘Ø±/ØµØºÙ‘Ø± Ø­Ø¬Ù… Ø§Ù„Ø®Ù„ÙŠØ© Ù…Ù† Ù‡Ù†Ø§ */
            --gap: 8px;
        }
        
        html,
        body {
            height: 100%;
        }
        
        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Naskh Arabic", "Amiri", "Cairo", Arial, sans-serif;
        }
        
        .app {
            width: min(1100px, 100%);
            margin: 16px auto;
            /* ÙŠÙˆØ³Ù‘Ø· Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø£ÙÙ‚ÙŠØ§Ù‹ ÙˆÙŠØ¨Ø¯Ø£ Ù…Ù† Ø£Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø© */
        }
        
        header {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            /* ÙŠØ®Ù„ÙŠ Ø§Ù„Ù‡ÙŠØ¯Ø± Ø«Ø§Ø¨Øª ÙÙˆÙ‚ */
            position: sticky;
            top: 0;
            z-index: 5;
            background: var(--bg);
            padding-block: 8px;
        }
        
        .title {
            font-weight: 800;
            font-size: clamp(22px, 2.8vw, 32px);
        }
        
        .sub {
            color: var(--muted);
            font-size: 15px;
        }
        
        .card {
            background: var(--card);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--shadow);
            border: 1px solid #eee;
        }
        
        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }
        
        .stats {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .chip {
            background: #fff4ef;
            color: #ff5722;
            padding: 8px 12px;
            border-radius: 999px;
            font-size: 14px;
            font-weight: 600;
        }
        
        .btn {
            border: 0;
            padding: 12px 16px;
            border-radius: 10px;
            background: var(--accent);
            color: #fff;
            cursor: pointer;
            font-weight: 700;
            box-shadow: 0 4px 12px rgba(255, 112, 67, .3);
            transition: transform .05s ease;
        }
        
        .btn:active {
            transform: translateY(1px)
        }
        
        .btn.secondary {
            background: #e5e7eb;
            color: #111;
            box-shadow: none;
        }
        
        .btn.good {
            background: var(--ok);
            box-shadow: 0 4px 12px rgba(76, 175, 80, .25);
        }
        
        .btn.bad {
            background: var(--bad);
        }
        /* Ø§Ù„Ø´Ø¨ÙƒØ©: Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© = gridSizeØŒ ÙˆØ­Ø¬Ù… Ø§Ù„Ø®Ù„ÙŠØ© Ù…Ù† --cell */
        
        .grid-container {
            display: grid;
            grid-template-columns: repeat(var(--cols, 8), var(--cell));
            gap: var(--gap);
            margin-top: 20px;
            width: fit-content;
            margin-inline: auto;
            /* ØªÙˆØ³ÙŠØ· Ø§Ù„Ø´Ø¨ÙƒØ© */
        }
        
        .grid-cell {
            width: var(--cell);
            aspect-ratio: 1;
            background: #fff;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(var(--cell) * .5);
            font-weight: 700;
            cursor: pointer;
            transition: all .2s ease;
            user-select: none;
        }
        
        .grid-cell:hover {
            background: #fef9f6;
            border-color: #ffdccf;
        }
        
        .grid-cell.selected {
            background: #ffe9e0;
            border-color: var(--accent);
            color: #ff5722;
        }
        
        .grid-cell.correct {
            /* Ø£Ù„ÙˆØ§Ù†Ù‡Ø§ ØªÙØ¶Ø¨Ø· inline Ø­Ø³Ø¨ ÙƒÙ„ ÙƒÙ„Ù…Ø© */
        }
        
        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        .word-item {
            background: #f5f5f5;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 16px;
            transition: .2s;
            border: 1px solid transparent;
        }
        
        .word-item.found {
            text-decoration: line-through;
            /* Ø§Ù„Ù„ÙˆÙ† ÙˆØ§Ù„Ø­Ø¯Ù‘ ØªÙØ¶Ø¨Ø· inline Ø­Ø³Ø¨ Ù„ÙˆÙ† Ø§Ù„ÙƒÙ„Ù…Ø© */
        }
        
        .hint-box {
            background: #fff8e1;
            border: 1px dashed #ffd54f;
            padding: 18px 20px;
            border-radius: 12px;
            margin-top: 20px;
            color: #ff8f00;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result {
            margin-top: 20px;
            font-weight: 800;
            font-size: 20px;
            display: none;
            padding: 14px 16px;
            border-radius: 12px;
            text-align: center;
        }
        
        .result.ok {
            display: block;
            background: #ecfdf5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }
        
        .result.bad {
            display: block;
            background: #fef2f2;
            color: #7f1d1d;
            border: 1px solid #fecaca;
        }
        
        .footer {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            align-items: center;
            margin-top: 16px;
        }
        
        .progress {
            --p: 0%;
            width: 100%;
            height: 12px;
            background: #e5e7eb;
            border-radius: 999px;
            overflow: hidden;
            position: relative;
        }
        
        .progress::after {
            content: "";
            position: absolute;
            inset: 0;
            width: var(--p);
            background: linear-gradient(90deg, #ff7043, #ff9800);
        }
        
        .ribbon {
            position: fixed;
            inset-inline-end: 12px;
            inset-block-start: 12px;
            background: #fff;
            padding: 8px 12px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            border: 1px solid #eee;
            font-size: 13px;
            color: #111;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        dialog {
            border: 0;
            border-radius: 16px;
            padding: 0;
            box-shadow: var(--shadow);
            width: min(600px, 95vw);
        }
        
        .modal-body {
            padding: 20px;
        }
        
        .modal-head {
            padding: 16px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        input,
        select,
        textarea {
            width: 100%;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            background: #fff;
            font-family: inherit;
        }
        
        label {
            font-size: 14px;
            color: #374151;
        }
        
        .grid {
            display: grid;
            gap: 12px;
            grid-template-columns: 1fr 1fr;
        }
        
        .grid>div {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .tiny {
            font-size: 13px;
            color: var(--muted);
        }
        
        .level-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .level-card {
            background: #fff;
            border-radius: 14px;
            padding: 16px;
            box-shadow: var(--shadow);
            border: 2px solid #eee;
            cursor: pointer;
            transition: transform .2s, border-color .2s;
        }
        
        .level-card:hover {
            transform: translateY(-3px);
            border-color: var(--accent);
        }
        
        .level-card.active {
            border-color: var(--accent);
            background: #fff8f5;
        }
        
        .level-title {
            font-weight: 800;
            font-size: 18px;
            margin-bottom: 8px;
        }
        
        .level-desc {
            font-size: 13px;
            color: var(--muted);
        }
        
        .action-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            gap: 10px;
        }
        
        .action-buttons {
            display: flex;
            gap: 8px;
        }
        
        @media (max-width:600px) {
            .grid-cell {
                font-size: calc(var(--cell) * .45);
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <header class="row">
            <div>
                <div class="title">ğŸ® Ù„Ø¹Ø¨Ø© <span style="color:var(--accent)">ØµÙŠØ§Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª</span></div>
                <div class="sub">Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø®ÙÙŠØ© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©</div>
            </div>
            <div class="stats">
                <div class="chip">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <span id="levelNow">1</span></div>
                <div class="chip">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="scoreNow">0</span> â­</div>
                <button class="btn secondary" id="btnLevels">Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</button>
                <button class="btn secondary" id="btnTeacher">ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‘Ù…</button>
            </div>
        </header>

        <div class="card board">
            <div class="hint-box">
                <div>
                    <span>ğŸ’¡ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª:</span>
                    <strong id="instructionText">Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„Ø£ÙÙ‚ÙŠØ© ÙˆØ§Ù„Ø¹Ù…ÙˆØ¯ÙŠØ© ÙÙ‚Ø·</strong>
                </div>
                <div>Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©: <span id="wordsFound">0</span>/<span id="totalWords">0</span></div>
            </div>

            <div class="grid-container" id="gameGrid"></div>

            <div class="word-list" id="wordList"></div>

            <div class="result" id="result"></div>

            <div class="footer">
                <button class="btn" id="btnHint">Ø§Ø³ØªØ®Ø¯Ù… ØªÙ„Ù…ÙŠØ­ ğŸª„</button>
                <div class="progress" id="progress"></div>
                <div style="display:flex; gap:8px; flex-wrap:wrap;">
                    <button class="btn secondary" id="btnResetLevel">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø³ØªÙˆÙ‰ â†º</button>
                    <button class="btn bad" id="btnReset">Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ â†º</button>
                    <button class="btn good" id="btnNext" disabled>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ â–¶</button>
                </div>
            </div>
        </div>
    </div>

    <div class="ribbon">ğŸ§  ØªÙ‚Ø¯Ù‘Ù…Ùƒ Ù…Ø­ÙÙˆØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§</div>

    <!-- Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª -->
    <dialog id="levelsDlg">
        <div class="modal-head">
            <strong>Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨</strong>
            <button class="btn secondary" onclick="levelsDlg.close()">Ø¥ØºÙ„Ø§Ù‚</button>
        </div>
        <div class="modal-body">
            <div class="level-selector" id="levelSelector">
                <div class="level-card" data-level="1">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø£ÙˆÙ„</div>
                    <div class="level-desc">ÙƒÙ„Ù…Ø§Øª Ø¨Ø³ÙŠØ·Ø© Ù…Ù† 3-4 Ø£Ø­Ø±Ù</div>
                </div>
                <div class="level-card" data-level="2">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ø§Ù†ÙŠ</div>
                    <div class="level-desc">ÙƒÙ„Ù…Ø§Øª Ù…Ù† 4-5 Ø£Ø­Ø±Ù Ø£ÙƒØ«Ø± ØªÙ†ÙˆØ¹Ù‹Ø§</div>
                </div>
                <div class="level-card" data-level="3">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ø§Ù„Ø«</div>
                    <div class="level-desc">ÙƒÙ„Ù…Ø§Øª ØªØ¹Ø¨Ø± Ø¹Ù† Ø§Ù„Ø£Ù†Ø´Ø·Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©</div>
                </div>
                <div class="level-card" data-level="4">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø±Ø§Ø¨Ø¹</div>
                    <div class="level-desc">ÙƒÙ„Ù…Ø§Øª Ù…Ù† Ø¯Ø±ÙˆØ³ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</div>
                </div>
                <div class="level-card" data-level="5">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø§Ù…Ø³</div>
                    <div class="level-desc">ØªØ­Ø¯ÙŠ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø§Ø·Ø¹Ø©</div>
                </div>
            </div>
            <div class="action-bar">
                <div class="action-buttons">
                    <button class="btn secondary" id="btnClearLevelProgress">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ</button>
                    <button class="btn secondary" id="btnClearAllProgress">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙƒÙ„ Ø§Ù„ØªÙ‚Ø¯Ù…</button>
                </div>
            </div>
        </div>
    </dialog>

    <!-- Ù„ÙˆØ­Ø© Ø§Ù„Ù…Ø¹Ù„Ù‘Ù… -->
    <dialog id="teacherDlg">
        <div class="modal-head">
            <strong>ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‘Ù… (Ø¥Ø¶Ø§ÙØ© ÙƒÙ„Ù…Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©)</strong>
            <button class="btn secondary" onclick="teacherDlg.close()">Ø¥ØºÙ„Ø§Ù‚</button>
        </div>
        <div class="modal-body">
            <div class="tiny">Ø£Ø¶Ù ÙƒÙ„Ù…Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø¹Ø¨Ø©. ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø© ÙƒÙ„Ù…Ø§Øª.</div>
            <div class="grid">
                <div>
                    <label>Ø§Ù„ÙƒÙ„Ù…Ø§Øª (Ø§ÙØµÙ„ Ø¨ÙŠÙ†Ù‡Ø§ Ø¨ÙØ§ØµÙ„Ø©):</label>
                    <textarea id="tWords" rows="4" placeholder="Ù…Ø«Ø§Ù„: Ù‚Ù„Ù…ØŒ ÙƒØªØ§Ø¨ØŒ Ù…Ø¯Ø±Ø³Ø©"></textarea>
                </div>
                <div>
                    <label>Ø§Ù„Ù…Ø³ØªÙˆÙ‰:</label>
                    <select id="tLevel">
            <option value="1">1 (ÙƒÙ„Ù…Ø§Øª Ø¨Ø³ÙŠØ·Ø©)</option>
            <option value="2">2 (ÙƒÙ„Ù…Ø§Øª Ù…ØªÙ†ÙˆØ¹Ø©)</option>
            <option value="3">3 (Ø§Ù„Ø£Ù†Ø´Ø·Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©)</option>
            <option value="4">4 (Ø¯Ø±ÙˆØ³ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)</option>
            <option value="5">5 (ÙƒÙ„Ù…Ø§Øª Ù…ØªÙ‚Ø§Ø·Ø¹Ø©)</option>
          </select>
                </div>
            </div>
            <div style="margin-top:10px;">
                <label>Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù„Ù„Ø·Ù„Ø§Ø¨ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):</label>
                <input id="tNotes" placeholder="Ù…Ø«Ø§Ù„: ÙƒÙ„Ù…Ø§Øª Ù…Ù† Ø¯Ø±Ø³ Ø§Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª">
            </div>
            <div class="row" style="margin-top:12px;">
                <button class="btn" id="btnAddWords">Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙ„Ù…Ø§Øª â•</button>
                <button class="btn bad" id="btnClearAll">Ø­Ø°Ù Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø¶Ø§ÙØ© ğŸ—‘ï¸</button>
            </div>
            <div class="tiny" style="margin-top:8px;">Ù†ØµÙŠØ­Ø©: Ø£Ø¶Ù ÙƒÙ„Ù…Ø§Øª Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù…ÙˆØ¶ÙˆØ¹ ÙˆØ§Ø­Ø¯ ÙÙŠ ÙƒÙ„ Ù…Ø±Ø© Ù„ØªØ³Ù‡ÙŠÙ„ Ø§Ù„ØªØ¹Ù„Ù….</div>
        </div>
    </dialog>

    <script>
        (() => {
            // ========== Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ==========
            const builtInBank = {
                1: [{
                    words: ["Ù‚Ù„Ù…", "ÙƒØªØ§Ø¨", "Ø¨Ø§Ø¨", "Ø¹Ù„Ù…", "ÙˆÙ„Ø¯", "Ø¨Ù†Øª"],
                    notes: "ÙƒÙ„Ù…Ø§Øª Ù…Ù† Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ù…Ø¯Ø±Ø³ÙŠØ©"
                }, {
                    words: ["Ø£Ø³Ø¯", "Ù†Ù…Ø±", "ÙÙŠÙ„", "Ù‚Ø±Ø¯", "Ø¯Ø¨", "Ø¬Ù…Ù„"],
                    notes: "Ø£Ø³Ù…Ø§Ø¡ Ø­ÙŠÙˆØ§Ù†Ø§Øª"
                }, {
                    words: ["Ù…Ø§Ø¡", "ØªÙ…Ø±", "Ø¹Ù†Ø¨", "Ù…ÙˆØ²", "ØªÙŠÙ†", "Ø®Ø¨Ø²"],
                    notes: "Ø£Ø³Ù…Ø§Ø¡ Ø·Ø¹Ø§Ù… ÙˆØ´Ø±Ø§Ø¨"
                }],
                2: [{
                    words: ["Ù…Ø¯Ø±Ø³Ø©", "Ù…Ø¹Ù„Ù…", "Ø·Ø§Ù„Ø¨", "Ø¯ÙØªØ±", "ÙƒØ±Ø³ÙŠ", "ÙØµÙ„"],
                    notes: "ÙƒÙ„Ù…Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø¯Ø±Ø³Ø©"
                }, {
                    words: ["Ø¨ÙŠØª", "ØºØ±ÙØ©", "Ù…Ø·Ø¨Ø®", "Ø­Ù…Ø§Ù…", "Ø³Ø±ÙŠØ±", "Ø¨Ø§Ø¨"],
                    notes: "Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ù†Ø²Ù„"
                }, {
                    words: ["Ø³ÙŠØ§Ø±Ø©", "Ø¯Ø±Ø§Ø¬Ø©", "Ø·Ø§Ø¦Ø±Ø©", "Ù‚Ø·Ø§Ø±", "Ø¨Ø§Øµ", "Ø³ÙÙŠÙ†Ø©"],
                    notes: "ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„Ù†Ù‚Ù„"
                }],
                3: [{
                    words: ["ÙŠÙ‚Ø±Ø£", "ÙŠÙƒØªØ¨", "ÙŠÙ„Ø¹Ø¨", "ÙŠØ£ÙƒÙ„", "ÙŠÙ†Ø§Ù…", "ÙŠØ¬Ø±ÙŠ"],
                    notes: "Ø£ÙØ¹Ø§Ù„ ÙŠÙˆÙ…ÙŠØ©"
                }, {
                    words: ["ØµØ¨Ø§Ø­", "Ù…Ø³Ø§Ø¡", "Ø¸Ù‡Ø±", "Ù„ÙŠÙ„", "Ù†Ù‡Ø§Ø±", "ØºØ±ÙˆØ¨"],
                    notes: "Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ÙŠÙˆÙ…"
                }, {
                    words: ["Ø£Ø­Ù…Ø±", "Ø£Ø²Ø±Ù‚", "Ø£ØµÙØ±", "Ø£Ø®Ø¶Ø±", "Ø£Ø³ÙˆØ¯", "Ø£Ø¨ÙŠØ¶"],
                    notes: "Ø§Ù„Ø£Ù„ÙˆØ§Ù†"
                }],
                4: [{
                    words: ["Ø­Ø¯ÙŠÙ‚Ø©", "Ù…Ø²Ø±Ø¹Ø©", "Ø´Ø¬Ø±Ø©", "Ø²Ù‡Ø±Ø©", "Ø¹ØµÙÙˆØ±", "ÙØ±Ø§Ø´Ø©"],
                    notes: "ÙƒÙ„Ù…Ø§Øª Ù…Ù† Ø§Ù„Ø·Ø¨ÙŠØ¹Ø©"
                }, {
                    words: ["Ø§Ù„Ù…Ø¹Ù„Ù…", "Ø§Ù„ØªÙ„Ù…ÙŠØ°", "Ø§Ù„Ù…Ø¯Ø±Ø³Ø©", "Ø§Ù„ÙƒØªØ§Ø¨", "Ø§Ù„Ù‚Ù„Ù…", "Ø§Ù„Ø³Ø¨ÙˆØ±Ø©"],
                    notes: "ÙƒÙ„Ù…Ø§Øª Ø¨Ù‡Ø§ Ø§Ù„ Ø§Ù„ØªØ¹Ø±ÙŠÙ"
                }, {
                    words: ["Ø±Ø³Ø§Ù„Ø©", "Ù‚ØµØ©", "Ø­ÙƒØ§ÙŠØ©", "ÙƒÙ„Ù…Ø©", "Ø¬Ù…Ù„Ø©", "Ø­Ø±Ù"],
                    notes: "ÙƒÙ„Ù…Ø§Øª Ø¹Ù† Ø§Ù„Ù„ØºØ©"
                }],
                5: [{
                    words: ["Ù…Ø³Ø¬Ø¯", "Ù…Ø¯Ø±Ø³Ø©", "Ù…Ø³ØªØ´ÙÙ‰", "Ù…ØªØ­Ù", "Ù…ÙƒØªØ¨Ø©", "Ù…ØªÙ†Ø²Ù‡"],
                    notes: "Ø£Ù…Ø§ÙƒÙ† Ø¹Ø§Ù…Ø©"
                }, {
                    words: ["ØµØ¯ÙŠÙ‚", "Ø£Ø®ÙŠ", "Ø£Ù…ÙŠ", "Ø£Ø¨ÙŠ", "Ø¬Ø¯ÙŠ", "Ø¹Ù…ÙŠ"],
                    notes: "Ø§Ù„Ø£Ø³Ø±Ø© ÙˆØ§Ù„Ø£Ù‚Ø§Ø±Ø¨"
                }, {
                    words: ["Ù†Ø¸ÙŠÙ", "Ø¬Ù…ÙŠÙ„", "ÙƒØ¨ÙŠØ±", "ØµØºÙŠØ±", "Ø·ÙˆÙŠÙ„", "Ù‚ØµÙŠØ±"],
                    notes: "ØµÙØ§Øª"
                }]
            };

            // ØªØ­Ù…ÙŠÙ„ ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‘Ù… Ù…Ù† Ø§Ù„ØªØ®Ø²ÙŠÙ†
            const teacherKey = "wf_teacher_words_v1";
            const loadTeacherWords = () => {
                try {
                    return JSON.parse(localStorage.getItem(teacherKey) || "{}");
                } catch {
                    return {};
                }
            };
            const saveTeacherWords = (data) => localStorage.setItem(teacherKey, JSON.stringify(data || {}));

            // Ø¯Ù…Ø¬ Ø§Ù„Ø¨Ù†ÙˆÙƒ
            function getFullBank() {
                const t = loadTeacherWords();
                const merged = {
                    1: [...builtInBank[1]],
                    2: [...builtInBank[2]],
                    3: [...builtInBank[3]],
                    4: [...builtInBank[4]],
                    5: [...builtInBank[5]]
                };
                for (const lvl of[1, 2, 3, 4, 5]) {
                    if (t[lvl]) merged[lvl].push(...t[lvl]);
                }
                return merged;
            }

            // Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
            const stateKey = "wf_state_v1";

            function loadState() {
                try {
                    return JSON.parse(localStorage.getItem(stateKey)) || {
                        level: 1,
                        score: 0,
                        done: {},
                        currentLevel: 0,
                        currentPuzzle: 0
                    };
                } catch {
                    return {
                        level: 1,
                        score: 0,
                        done: {},
                        currentLevel: 0,
                        currentPuzzle: 0
                    };
                }
            }
            const state = loadState();
            const saveState = () => localStorage.setItem(stateKey, JSON.stringify(state));

            // Ø¹Ù†Ø§ØµØ± DOM
            const el = {
                levelNow: document.getElementById("levelNow"),
                scoreNow: document.getElementById("scoreNow"),
                instructionText: document.getElementById("instructionText"),
                wordsFound: document.getElementById("wordsFound"),
                totalWords: document.getElementById("totalWords"),
                gameGrid: document.getElementById("gameGrid"),
                wordList: document.getElementById("wordList"),
                result: document.getElementById("result"),
                btnHint: document.getElementById("btnHint"),
                btnReset: document.getElementById("btnReset"),
                btnResetLevel: document.getElementById("btnResetLevel"),
                btnNext: document.getElementById("btnNext"),
                progress: document.getElementById("progress"),
                btnTeacher: document.getElementById("btnTeacher"),
                btnLevels: document.getElementById("btnLevels"),
                teacherDlg: document.getElementById("teacherDlg"),
                levelsDlg: document.getElementById("levelsDlg"),
                levelSelector: document.getElementById("levelSelector"),
                btnClearLevelProgress: document.getElementById("btnClearLevelProgress"),
                btnClearAllProgress: document.getElementById("btnClearAllProgress"),
                tWords: document.getElementById("tWords"),
                tLevel: document.getElementById("tLevel"),
                tNotes: document.getElementById("tNotes"),
                btnAddWords: document.getElementById("btnAddWords"),
                btnClearAll: document.getElementById("btnClearAll")
            };

            // Ù…Ø¤Ø«Ø± ØµÙˆØªÙŠ Ø¨Ø³ÙŠØ·
            const ctx = new(window.AudioContext || window.webkitAudioContext)();
            // ØªØ£ÙƒÙŠØ¯ ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª (ÙŠÙÙƒÙ‘ Ø§Ù„Ù‚ÙÙ„ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©)
            function ensureAudio() {
                if (ctx && ctx.state !== 'running') {
                    ctx.resume().catch(() => {});
                }
            }
            // Ø£ÙˆÙ„ ØªÙØ§Ø¹Ù„ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù†ÙÙƒ Ø§Ù„Ù‚ÙÙ„
            ['pointerdown', 'touchstart', 'keydown', 'click'].forEach(evt => {
                window.addEventListener(evt, () => ensureAudio(), {
                    once: true,
                    passive: true
                });
            });
            // Ù„Ùˆ Ø±Ø¬Ø¹Øª Ø§Ù„ØµÙØ­Ø© Ù…Ù† Ø§Ù„Ø®Ù„ÙÙŠØ© ÙˆÙƒØ§Ù† Ø§Ù„Ø³ÙŠØ§Ù‚ Ù…Ø¹Ù„Ù‘Ù‚
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') ensureAudio();
            });

            function beep(freq = 880, ms = 120, type = "sine", vol = .03) {
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = type;
                o.frequency.value = freq;
                g.gain.value = vol;
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                setTimeout(() => o.stop(), ms);
            }

            const rand = (arr) => arr[Math.floor(Math.random() * arr.length)];

            // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
            let gridSize = 8;
            let grid = [];
            let words = [];
            let foundWords = [];
            let selectedCells = [];
            let currentDirection = null;

            // Ø¹Ø¯Ù‘Ø§Ø¯Ø§Øª Ù„ØªÙˆØ§Ø²Ù† Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª (Ù†Øµ Ø¨Ø§Ù„Ù†Øµ)
            let placedHoriz = 0;
            let placedVert = 0;

            // Ø£Ù„ÙˆØ§Ù† Ù„ÙƒÙ„ ÙƒÙ„Ù…Ø©
            const COLORS = ['#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'];
            const wordColors = {}; // word -> color

            // Fallback Ø¨Ø³ÙŠØ· Ù„Ù€ CSS.escape (Ù„Ø¯Ø¹Ù… Ù…ØªØµÙØ­Ø§Øª Ù‚Ø¯ÙŠÙ…Ø©)
            if (typeof window.CSS === 'undefined') window.CSS = {};
            if (typeof window.CSS.escape !== 'function') {
                window.CSS.escape = (s) => s.replace(/[^a-zA-Z0-9_\u0600-\u06FF-]/g, '\\$&');
            }

            // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø¬Ø¯ÙŠØ¯Ø©
            function createGrid(size) {
                gridSize = size;
                grid = [];
                for (let i = 0; i < size; i++) {
                    grid[i] = [];
                    for (let j = 0; j < size; j++) {
                        grid[i][j] = '';
                    }
                }
            }

            // Ø­Ø¬Ù… Ø§Ù„Ø´Ø¨ÙƒØ© Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ (Ù„ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©)
            function gridSizeForLevel(level) {
                switch (level) {
                    case 1:
                        return 4; // ÙƒÙ„Ù…Ø§Øª Ù‚ØµÙŠØ±Ø©
                    case 2:
                        return 5;
                    case 3:
                        return 6;
                    case 4:
                        return 7;
                    case 5:
                    default:
                        return 8; // Ù…Ø³ØªÙˆÙ‰ Ø£Ø¹Ù„Ù‰
                }
            }

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø±Ø¦ÙŠ Ù„Ù„Ø´Ø¨ÙƒØ©
            function renderGrid() {
                el.gameGrid.style.setProperty('--cols', gridSize);
                el.gameGrid.innerHTML = '';
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.textContent = grid[i][j] || '';
                        cell.addEventListener('mousedown', (e) => startSelection(i, j, e));
                        cell.addEventListener('mouseover', (e) => continueSelection(i, j, e));
                        cell.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            startSelection(i, j, e);
                        });
                        cell.addEventListener('touchmove', (e) => {
                            e.preventDefault();
                            const t = e.touches[0];
                            const elAt = document.elementFromPoint(t.clientX, t.clientY);
                            if (elAt && elAt.classList.contains('grid-cell')) {
                                const r = parseInt(elAt.dataset.row);
                                const c = parseInt(elAt.dataset.col);
                                continueSelection(r, c, e);
                            }
                        });
                        el.gameGrid.appendChild(cell);
                    }
                }
                document.addEventListener('mouseup', endSelection);
                document.addEventListener('touchend', endSelection);
            }

            // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª
            function renderWordList() {
                el.wordList.innerHTML = '';
                words.forEach(word => {
                    const item = document.createElement('div');
                    item.className = 'word-item' + (foundWords.includes(word) ? ' found' : '');
                    item.textContent = word;
                    item.dataset.word = word;

                    // Ù„Ùˆ Ø§Ù„ÙƒÙ„Ù…Ø© Ù„Ù‡Ø§ Ù„ÙˆÙ†ØŒ Ø·Ø¨Ù‘Ù‚Ù‡
                    if (foundWords.includes(word) && wordColors[word]) {
                        item.style.color = wordColors[word];
                        item.style.border = `1px solid ${wordColors[word]}`;
                        item.style.background = '#fff';
                    }

                    el.wordList.appendChild(item);
                });
                el.wordsFound.textContent = foundWords.length;
                el.totalWords.textContent = words.length;
            }

            // Ù…Ø­Ø§ÙˆÙ„Ø© ÙˆØ¶Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒÙ„Ù…Ø§Øª
            function validateWordPlacement() {
                let attemptCount = 0,
                    maxAttempts = 5;
                while (attemptCount < maxAttempts) {
                    // ØªØµÙÙŠØ± Ø§Ù„Ø¹Ø¯Ù‘Ø§Ø¯Ø§Øª ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø©
                    placedHoriz = 0;
                    placedVert = 0;

                    createGrid(gridSize);
                    let allWordsPlaced = true;
                    for (const w of words) {
                        if (!placeWord(w)) {
                            allWordsPlaced = false;
                            break;
                        }
                    }
                    if (allWordsPlaced) return true;
                    attemptCount++;
                }
                console.warn("Ù„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† ÙˆØ¶Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø¨Ø¹Ø¯ Ø¹Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø§Øª");
                return false;
            }

            // Ø¯Ø§Ù„Ø© ÙˆØ¶Ø¹ ÙƒÙ„Ù…Ø© Ù…Ø¹ ØªÙˆØ§Ø²Ù† Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª + Ø§Ù„Ø£Ø±Ø¨Ø¹Ø© Ø§ØªØ¬Ø§Ù‡Ø§Øª
            function placeWord(word) {
                const horizontal = [
                    [0, 1],
                    [0, -1]
                ]; // ÙŠÙ…ÙŠÙ†/ÙŠØ³Ø§Ø±
                const vertical = [
                    [1, 0],
                    [-1, 0]
                ]; // Ø£Ø³ÙÙ„/Ø£Ø¹Ù„Ù‰

                // Ù†ÙØ¶Ù‘Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø£Ù‚Ù„ Ø¹Ø¯Ø¯Ø§Ù‹ Ø­ØªÙ‰ Ø§Ù„Ø¢Ù† (Ù†Øµ Ø¨Ø§Ù„Ù†Øµ ÙØ¹Ù„ÙŠ)
                const preferHorizontal = placedHoriz <= placedVert;
                const groups = preferHorizontal ? [horizontal, vertical] : [vertical, horizontal];

                for (const group of groups) {
                    const dirs = group.slice().sort(() => Math.random() - 0.5);
                    for (const [dy, dx] of dirs) {
                        for (let attempt = 0; attempt < 60; attempt++) {
                            const row = Math.floor(Math.random() * gridSize);
                            const col = Math.floor(Math.random() * gridSize);
                            if (canPlaceWord(word, row, col, dy, dx)) {
                                for (let i = 0; i < word.length; i++) {
                                    const r = row + i * dy,
                                        c = col + i * dx;
                                    grid[r][c] = word[i];
                                }
                                if (dy === 0) placedHoriz++;
                                else placedVert++;
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function canPlaceWord(word, row, col, dy, dx) {
                for (let i = 0; i < word.length; i++) {
                    const r = row + i * dy,
                        c = col + i * dx;
                    if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) return false;
                    if (grid[r][c] && grid[r][c] !== word[i]) return false;
                }
                return true;
            }

            // Ù…Ù„Ø¡ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©
            function fillRandomLetters() {
                const arabicLetters = "Ø£Ø¨ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹ØºÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙŠ";
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (!grid[i][j]) grid[i][j] = arabicLetters[Math.floor(Math.random() * arabicLetters.length)];
                    }
                }
            }

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø­Ø±ÙˆÙ
            function startSelection(row, col) {
                clearSelection();
                selectedCells.push({
                    row,
                    col
                });
                updateSelectedCells();
                currentDirection = null;
            }

            function continueSelection(row, col) {
                if (selectedCells.length === 0) return;
                if (selectedCells.some(c => c.row === row && c.col === col)) return;

                const first = selectedCells[0],
                    last = selectedCells[selectedCells.length - 1];

                if (selectedCells.length === 1) {
                    if (row === first.row) {
                        currentDirection = {
                            dy: 0,
                            dx: Math.sign(col - first.col)
                        };
                    } else if (col === first.col) {
                        currentDirection = {
                            dy: Math.sign(row - first.row),
                            dx: 0
                        };
                    } else return;
                } else {
                    const er = last.row + currentDirection.dy,
                        ec = last.col + currentDirection.dx;
                    if (row !== er || col !== ec) return;
                }

                selectedCells.push({
                    row,
                    col
                });
                updateSelectedCells();
            }

            function endSelection() {
                if (selectedCells.length === 0) return;
                const selectedWord = selectedCells.map(c => grid[c.row][c.col]).join('');
                if (words.includes(selectedWord) && !foundWords.includes(selectedWord)) {
                    foundWords.push(selectedWord);

                    // Ù„ÙˆÙ† Ø«Ø§Ø¨Øª Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙƒÙ„Ù…Ø©
                    const paletteIndex = Object.keys(wordColors).length % COLORS.length;
                    const color = wordColors[selectedWord] || (wordColors[selectedWord] = COLORS[paletteIndex]);

                    // Ù„ÙˆÙ‘Ù† Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ø§Ù„ØµØ­ÙŠØ­Ø©
                    markCellsAsCorrect(color);

                    // Ø­Ø¯Ù‘Ø« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© ÙˆÙ„ÙˆÙ‘Ù† Ø§Ù„Ø¹Ù†ØµØ±
                    renderWordList();
                    const item = el.wordList.querySelector(`[data-word="${CSS.escape(selectedWord)}"]`);
                    if (item) {
                        item.classList.add('found');
                        item.style.color = color;
                        item.style.border = `1px solid ${color}`;
                        item.style.background = '#fff';
                    }

                    beep(1200, 120, "square", .03);
                    state.score += 10;
                    el.scoreNow.textContent = state.score;
                    saveState();
                    if (foundWords.length === words.length) puzzleCompleted();
                } else {
                    beep(200, 150, "sawtooth", .03);
                    clearSelection();
                }
                selectedCells = [];
                currentDirection = null;
            }

            function updateSelectedCells() {
                document.querySelectorAll('.grid-cell.selected').forEach(cell => {
                    if (!cell.classList.contains('correct')) cell.classList.remove('selected');
                });
                selectedCells.forEach(({
                    row,
                    col
                }) => {
                    const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
                    if (cell && !cell.classList.contains('correct')) cell.classList.add('selected');
                });
            }

            // ØªÙ„ÙˆÙŠÙ† Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ø§Ù„ØµØ­ÙŠØ­Ø© Ø¨Ù„ÙˆÙ† Ø§Ù„ÙƒÙ„Ù…Ø©
            function markCellsAsCorrect(color = '#4caf50') {
                selectedCells.forEach(({
                    row,
                    col
                }) => {
                    const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                        cell.classList.remove('selected');
                        cell.classList.add('correct');
                        cell.style.borderColor = color;
                        cell.style.color = color;
                        cell.style.backgroundColor = '#fff';
                    }
                });
            }

            function clearSelection() {
                document.querySelectorAll('.grid-cell.selected').forEach(cell => {
                    if (!cell.classList.contains('correct')) cell.classList.remove('selected');
                });
                selectedCells = [];
            }

            // ØªÙ„Ù…ÙŠØ­ ÙŠØ¯Ø¹Ù… Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„Ø£Ø±Ø¨Ø¹Ø© (ÙˆØ¨Ù„ÙˆÙ† Ø§Ù„ÙƒÙ„Ù…Ø© Ø¥Ù† ÙˆÙØ¬Ø¯)
            function useHint() {
                const remaining = words.filter(w => !foundWords.includes(w));
                if (remaining.length === 0) return;
                const w = rand(remaining);

                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const directions = [
                            [0, 1], // Ø£ÙÙ‚ÙŠ ÙŠÙ…ÙŠÙ†
                            [0, -1], // Ø£ÙÙ‚ÙŠ ÙŠØ³Ø§Ø±
                            [1, 0], // Ø¹Ù…ÙˆØ¯ÙŠ Ø£Ø³ÙÙ„
                            [-1, 0], // Ø¹Ù…ÙˆØ¯ÙŠ Ø£Ø¹Ù„Ù‰
                        ];
                        for (const [dy, dx] of directions) {
                            if (checkWordAtPosition(w, i, j, dy, dx)) {
                                flashWord(w, i, j, dy, dx);
                                return;
                            }
                        }
                    }
                }
            }

            function checkWordAtPosition(word, row, col, dy, dx) {
                if (row + dy * (word.length - 1) >= gridSize || row + dy * (word.length - 1) < 0) return false;
                if (col + dx * (word.length - 1) >= gridSize || col + dx * (word.length - 1) < 0) return false;
                for (let i = 0; i < word.length; i++) {
                    const r = row + i * dy,
                        c = col + i * dx;
                    if (grid[r][c] !== word[i]) return false;
                }
                return true;
            }

            function flashWord(word, row, col, dy, dx) {
                const color = wordColors[word] || '#ffd54f';
                const cells = [];
                for (let i = 0; i < word.length; i++) {
                    const r = row + i * dy,
                        c = col + i * dx;
                    const cell = document.querySelector(`.grid-cell[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cells.push(cell);
                        cell.style.transition = "outline-color 0.3s, outline-width 0.3s";
                        cell.style.outline = `3px solid ${color}`;
                    }
                }
                setTimeout(() => cells.forEach(c => {
                    c.style.outline = "";
                }), 1000);
                state.score = Math.max(0, state.score - 5);
                el.scoreNow.textContent = state.score;
                saveState();
            }

            function puzzleCompleted() {
                el.result.className = "result ok";
                el.result.textContent = "ğŸ‰ Ø£Ø­Ø³Ù†Øª! Ù„Ù‚Ø¯ ÙˆØ¬Ø¯Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒÙ„Ù…Ø§Øª";
                el.result.style.display = "block";
                el.btnNext.disabled = false;
                state.score += 10;
                el.scoreNow.textContent = state.score;
                markPuzzleCompleted();
                confetti();
            }

            function getWordSet() {
                const bank = getFullBank()[state.level];
                if (!bank || bank.length === 0) return {
                    words: [],
                    notes: "Ù„Ø§ ØªÙˆØ¬Ø¯ ÙƒÙ„Ù…Ø§Øª"
                };
                if (state.currentPuzzle >= bank.length) state.currentPuzzle = 0;
                return bank[state.currentPuzzle];
            }

            // Ù…Ø¤Ø«Ø± Ø¨Ø³ÙŠØ·
            function confetti() {
                const n = 25,
                    dur = 1200;
                for (let i = 0; i < n; i++) {
                    const p = document.createElement("div");
                    p.style.position = "fixed";
                    p.style.width = "10px";
                    p.style.height = "10px";
                    p.style.background = `hsl(${Math.random()*360},90%,60%)`;
                    p.style.insetInlineStart = (Math.random() * 80 + 10) + "vw";
                    p.style.insetBlockStart = "0vh";
                    p.style.borderRadius = "2px";
                    p.style.transform = `rotate(${Math.random()*360}deg)`;
                    p.style.zIndex = 9999;
                    document.body.appendChild(p);
                    p.animate([{
                        transform: `translateY(0) rotate(0deg)`
                    }, {
                        transform: `translateY(80vh) rotate(${Math.random()*720-360}deg)`
                    }], {
                        duration: dur + Math.random() * 600,
                        easing: "cubic-bezier(.2,.7,.2,1)"
                    }).onfinish = () => p.remove();
                }
            }

            // Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø®ØªØ§Ø± Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª
            function setupLevelSelector() {
                const cards = el.levelSelector.querySelectorAll('.level-card');
                cards.forEach(card => {
                    const level = parseInt(card.dataset.level);
                    card.addEventListener('click', () => {
                        cards.forEach(c => c.classList.remove('active'));
                        card.classList.add('active');
                        state.level = level;
                        state.currentPuzzle = 0;
                        saveState();
                        el.levelsDlg.close();
                        createNewPuzzle();
                    });
                    if (level === state.level) card.classList.add('active');
                });
            }

            function markPuzzleCompleted() {
                if (!state.done[state.level]) state.done[state.level] = [];
                const key = `${state.level}-${state.currentPuzzle}`;
                if (!state.done[state.level].includes(key)) state.done[state.level].push(key);
                saveState();
                updateProgress();
            }

            function isPuzzleCompleted() {
                if (!state.done[state.level]) return false;
                const key = `${state.level}-${state.currentPuzzle}`;
                return state.done[state.level].includes(key);
            }

            function nextPuzzle() {
                state.currentPuzzle++;
                const bank = getFullBank()[state.level];
                if (state.currentPuzzle >= bank.length) state.currentPuzzle = 0;
                saveState();
                createNewPuzzle();
            }

            function updateProgress() {
                const bank = getFullBank()[state.level];
                if (!bank || bank.length === 0) return;
                const total = bank.length;
                let completed = 0;
                if (state.done[state.level]) {
                    bank.forEach((_, idx) => {
                        const key = `${state.level}-${idx}`;
                        if (state.done[state.level].includes(key)) completed++;
                    });
                }
                const percent = Math.round(100 * completed / total);
                el.progress.style.setProperty("--p", percent + "%");
            }

            // Ø¥Ù†Ø´Ø§Ø¡ Ù„ØºØ² Ø¬Ø¯ÙŠØ¯
            function createNewPuzzle() {
                foundWords = [];
                selectedCells = [];
                currentDirection = null;

                // ğŸ‘‡ Ø­Ø¬Ù… Ø§Ù„Ø´Ø¨ÙƒØ© Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø²Ø­Ù…Ø©
                gridSize = gridSizeForLevel(state.level);

                const wordSet = getWordSet();
                words = wordSet.words;

                // ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£Ø·ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹ ÙŠØ³Ø§Ø¹Ø¯ ÙŠÙ†Ø¬Ø­ Ø§Ù„ÙˆØ¶Ø¹
                words = [...words].sort((a, b) => b.length - a.length);

                el.instructionText.textContent = wordSet.notes || "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„Ø£ÙÙ‚ÙŠØ© ÙˆØ§Ù„Ø¹Ù…ÙˆØ¯ÙŠØ© ÙÙ‚Ø·";
                el.levelNow.textContent = state.level;
                el.scoreNow.textContent = state.score;

                const ok = validateWordPlacement();
                if (!ok) {
                    createGrid(gridSize);
                    // ØªØµÙÙŠØ± Ø§Ù„Ø¹Ø¯Ù‘Ø§Ø¯Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„Ø®Ø·Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
                    placedHoriz = 0;
                    placedVert = 0;
                    words.forEach(w => placeWord(w));
                }

                fillRandomLetters();
                renderGrid();
                renderWordList();

                el.result.style.display = "none";
                el.btnNext.disabled = true;
                updateProgress();
            }

            // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
            setupLevelSelector();
            createNewPuzzle();

            // Ø£Ø²Ø±Ø§Ø±
            el.btnHint.addEventListener("click", useHint);
            el.btnReset.addEventListener("click", () => {
                if (confirm("Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©ØŸ")) {
                    state.level = 1;
                    state.score = 0;
                    state.currentPuzzle = 0;
                    saveState();
                    createNewPuzzle();
                }
            });
            el.btnResetLevel.addEventListener("click", () => {
                if (confirm("Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠØŸ")) createNewPuzzle();
            });
            el.btnNext.addEventListener("click", nextPuzzle);
            el.btnTeacher.addEventListener("click", () => el.teacherDlg.showModal());
            el.btnLevels.addEventListener("click", () => {
                setupLevelSelector();
                el.levelsDlg.showModal();
            });

            el.btnClearLevelProgress.addEventListener("click", () => {
                if (confirm(`Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªÙ‚Ø¯Ù… Ù„Ù„Ù…Ø³ØªÙˆÙ‰ ${state.level}ØŸ`)) {
                    if (state.done[state.level]) {
                        state.done[state.level] = [];
                        saveState();
                        alert(`ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${state.level}`);
                        el.levelsDlg.close();
                        createNewPuzzle();
                    }
                }
            });
            el.btnClearAllProgress.addEventListener("click", () => {
                if (confirm("Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙƒÙ„ Ø§Ù„ØªÙ‚Ø¯Ù… ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§ØªØŸ")) {
                    state.done = {};
                    state.score = 0;
                    saveState();
                    alert("ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙƒÙ„ Ø§Ù„ØªÙ‚Ø¯Ù…");
                    el.levelsDlg.close();
                    createNewPuzzle();
                }
            });

            el.btnAddWords.addEventListener("click", () => {
                const wordsInput = (el.tWords.value || "").trim();
                if (!wordsInput) {
                    alert("Ø£Ø¶Ù Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø£ÙˆÙ„Ø§Ù‹ (Ù…ÙØµÙˆÙ„Ø© Ø¨ÙÙˆØ§ØµÙ„)");
                    return;
                }
                const list = wordsInput.split(/[,ØŒ]/).map(w => w.trim()).filter(w => w.length > 0);
                if (list.length === 0) {
                    alert("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„Ù…Ø§Øª ØµØ§Ù„Ø­Ø©");
                    return;
                }
                const lvl = parseInt(el.tLevel.value || "1");
                const notes = (el.tNotes.value || "").trim() || "ÙƒÙ„Ù…Ø§Øª Ù…Ø¶Ø§ÙØ© Ù…Ù† Ø§Ù„Ù…Ø¹Ù„Ù…";
                const data = loadTeacherWords();
                if (!data[lvl]) data[lvl] = [];
                data[lvl].push({
                    words: list,
                    notes
                });
                saveTeacherWords(data);
                el.tWords.value = "";
                el.tNotes.value = "";
                alert("ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ© âœ… Ø³ØªØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¹Ù†Ø¯ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ§Ù„ÙŠ.");
            });
            el.btnClearAll.addEventListener("click", () => {
                if (confirm("Ø­Ø°Ù ÙƒÙ„ ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‘Ù…ØŸ")) {
                    saveTeacherWords({});
                    alert("ØªÙ… Ø§Ù„Ø­Ø°Ù.");
                }
            });

        })();
    </script>
</body>

</html>