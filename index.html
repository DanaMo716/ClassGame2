<!doctype html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ù„Ø¹Ø¨Ø© ØµÙŠØ§Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª - ØªØ¹Ù„Ù‘Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</title>
    <style>
         :root {
            /* Ø£Ø­Ø¬Ø§Ù… Ù…Ø±ÙŠØ­Ø© Ù„Ù„Ø¬ÙˆØ§Ù„ */
            --bg: #f9f7f5;
            --card: #fff;
            --ink: #1f2937;
            --muted: #6b7280;
            --accent: #ff7043;
            --ok: #22c55e;
            --bad: #ef4444;
            --shadow: 0 8px 20px rgba(0, 0, 0, .08);
            /* Ø§Ù„Ø®Ù„ÙŠØ© ØªØªÙƒÙŠÙ‘Ù Ù…Ø¹ Ø¹Ø±Ø¶ Ø§Ù„Ø´Ø§Ø´Ø©: Ù…Ù† 44px Ø¥Ù„Ù‰ 64px */
            --cell: clamp(44px, 9.5vw, 64px);
            --gap: clamp(6px, 1.8vw, 10px);
            --radius: 14px;
            --base-font: clamp(16px, 3.6vw, 18px);
            --title: clamp(22px, 5.6vw, 32px);
            --chip: clamp(12px, 3.2vw, 14px);
            --btn-pad-y: clamp(10px, 2.4vw, 12px);
            --btn-pad-x: clamp(12px, 3vw, 16px);
        }
        
        html,
        body {
            height: 100%
        }
        
        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font-family: system-ui, -apple-system, "Segoe UI", "Cairo", "Noto Naskh Arabic", Arial, sans-serif;
            font-size: var(--base-font);
            -webkit-tap-highlight-color: transparent;
        }
        
        .app {
            width: min(1100px, 100%);
            margin-inline: auto;
            padding: 12px 12px 24px
        }
        
        header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--bg);
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            padding: 10px 2px;
            border-bottom: 1px solid #eee;
            backdrop-filter: saturate(1.2) blur(2px);
        }
        
        .title {
            font-weight: 800;
            font-size: var(--title);
            line-height: 1.2
        }
        
        .sub {
            color: var(--muted);
            font-size: clamp(13px, 3.2vw, 15px)
        }
        
        .stats {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: flex-end
        }
        
        .chip {
            background: #fff4ef;
            color: #ff5722;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: var(--chip);
            font-weight: 700;
            border: 1px solid #ffd7c7;
        }
        
        .btn {
            border: 0;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            border-radius: 12px;
            background: var(--accent);
            color: #fff;
            cursor: pointer;
            font-weight: 800;
            box-shadow: 0 4px 12px rgba(255, 112, 67, .28);
            touch-action: manipulation;
            user-select: none;
            transition: transform .05s ease, opacity .2s;
        }
        
        .btn:active {
            transform: translateY(1px)
        }
        
        .btn.secondary {
            background: #eef2f7;
            color: #111;
            box-shadow: none;
            border: 1px solid #e5e7eb
        }
        
        .btn.good {
            background: var(--ok)
        }
        
        .btn.bad {
            background: var(--bad)
        }
        
        .card {
            background: var(--card);
            border-radius: var(--radius);
            padding: 16px;
            box-shadow: var(--shadow);
            border: 1px solid #eee;
        }
        
        .hint-box {
            background: #fff8e1;
            border: 1px dashed #ffd54f;
            padding: 14px;
            border-radius: 12px;
            color: #b45309;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        /* Ø§Ù„Ø´Ø¨ÙƒØ© */
        
        .grid-container {
            display: grid;
            grid-template-columns: repeat(var(--cols, 8), var(--cell));
            gap: var(--gap);
            margin-top: 14px;
            width: fit-content;
            margin-inline: auto;
            touch-action: none;
            /* ÙŠØ­Ø³Ù‘Ù† Ø³Ø­Ø¨ Ø§Ù„Ø¥ØµØ¨Ø¹ */
        }
        
        .grid-cell {
            width: var(--cell);
            aspect-ratio: 1/1;
            background: #fff;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(var(--cell)*.54);
            font-weight: 900;
            letter-spacing: .5px;
            transition: all .15s ease;
            user-select: none;
        }
        
        .grid-cell:hover {
            background: #fff7f3;
            border-color: #ffdccf
        }
        
        .grid-cell.selected {
            background: #ffe9e0;
            border-color: var(--accent);
            color: #ff5722
        }
        
        .grid-cell.correct {
            /* Ø§Ù„Ù„ÙˆÙ† ÙŠÙØ·Ø¨Ù‘Ù‚ inline */
        }
        
        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 14px;
            justify-content: center
        }
        
        .word-item {
            background: #f5f7fa;
            padding: 8px 12px;
            border-radius: 10px;
            font-weight: 700;
            border: 1px solid #e5e7eb;
            font-size: clamp(15px, 3.6vw, 16px)
        }
        
        .word-item.found {
            text-decoration: line-through;
            background: #fff
        }
        
        .result {
            margin-top: 14px;
            font-weight: 900;
            font-size: clamp(18px, 4.8vw, 20px);
            display: none;
            padding: 12px 14px;
            border-radius: 12px;
            text-align: center
        }
        
        .result.ok {
            display: block;
            background: #ecfdf5;
            color: #065f46;
            border: 1px solid #a7f3d0
        }
        
        .result.bad {
            display: block;
            background: #fef2f2;
            color: #7f1d1d;
            border: 1px solid #fecaca
        }
        
        .footer {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            flex-wrap: wrap
        }
        
        .progress {
            --p: 0%;
            width: 100%;
            height: 12px;
            background: #e5e7eb;
            border-radius: 999px;
            overflow: hidden;
            position: relative
        }
        
        .progress::after {
            content: "";
            position: absolute;
            inset: 0;
            width: var(--p);
            background: linear-gradient(90deg, #ff7043, #ff9800)
        }
        
        .ribbon {
            position: fixed;
            inset-inline-end: 10px;
            inset-block-start: 10px;
            background: #fff;
            padding: 8px 10px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            border: 1px solid #eee;
            font-size: 12px;
            color: #111;
        }
        
        dialog {
            border: 0;
            border-radius: 16px;
            padding: 0;
            box-shadow: var(--shadow);
            width: min(560px, 95vw)
        }
        
        .modal-head {
            padding: 12px 14px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center
        }
        
        .modal-body {
            padding: 14px
        }
        
        input,
        select,
        textarea {
            width: 100%;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
            background: #fff;
            font-family: inherit;
            font-size: inherit
        }
        
        label {
            font-size: 14px;
            color: #374151
        }
        
        .grid {
            display: grid;
            gap: 10px;
            grid-template-columns: 1fr 1fr
        }
        
        .grid>div {
            display: flex;
            flex-direction: column;
            gap: 6px
        }
        
        .tiny {
            font-size: 13px;
            color: var(--muted)
        }
        
        .level-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 12px;
            margin-bottom: 12px
        }
        
        .level-card {
            background: #fff;
            border-radius: 12px;
            padding: 12px;
            box-shadow: var(--shadow);
            border: 2px solid #eee;
            cursor: pointer;
            transition: .2s
        }
        
        .level-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent)
        }
        
        .level-card.active {
            border-color: var(--accent);
            background: #fff8f5
        }
        
        .level-title {
            font-weight: 800;
            font-size: 16px;
            margin-bottom: 6px
        }
        
        .level-desc {
            font-size: 13px;
            color: var(--muted)
        }
        
        .action-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            gap: 8px
        }
        
        .action-buttons {
            display: flex;
            gap: 8px
        }
        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø¬ÙˆØ§Ù„ Ø§Ù„Ø¶ÙŠÙ‚ */
        
        @media (max-width:700px) {
            .stats {
                justify-content: flex-start
            }
            header {
                flex-wrap: wrap
            }
            .btn {
                font-size: clamp(14px, 3.6vw, 16px)
            }
            .card {
                padding: 12px
            }
            .hint-box {
                padding: 12px
            }
            .word-list {
                gap: 6px
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <div>
                <div class="title">ğŸ® Ù„Ø¹Ø¨Ø© <span style="color:var(--accent)">ØµÙŠØ§Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª</span></div>
                <div class="sub">Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø®ÙÙŠØ© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©</div>
            </div>
            <div class="stats">
                <div class="chip">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: <span id="levelNow">1</span></div>
                <div class="chip">Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="scoreNow">0</span> â­</div>
                <button class="btn secondary" id="btnLevels">Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</button>
                <button class="btn secondary" id="btnTeacher">ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‘Ù…</button>
            </div>
        </header>

        <div class="card">
            <div class="hint-box">
                <div><span>ğŸ’¡ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª:</span> <strong id="instructionText">Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙÙŠ Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„Ø£ÙÙ‚ÙŠØ© ÙˆØ§Ù„Ø¹Ù…ÙˆØ¯ÙŠØ© ÙÙ‚Ø·</strong></div>
                <div>Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©: <span id="wordsFound">0</span>/<span id="totalWords">0</span></div>
            </div>

            <div class="grid-container" id="gameGrid"></div>
            <div class="word-list" id="wordList"></div>
            <div class="result" id="result"></div>

            <div class="footer">
                <button class="btn" id="btnHint">Ø§Ø³ØªØ®Ø¯Ù… ØªÙ„Ù…ÙŠØ­ ğŸª„</button>
                <div class="progress" id="progress"></div>
                <div style="display:flex; gap:8px; flex-wrap:wrap;">
                    <button class="btn secondary" id="btnResetLevel">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø³ØªÙˆÙ‰ â†º</button>
                    <button class="btn bad" id="btnReset">Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ â†º</button>
                    <button class="btn good" id="btnNext" disabled>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ â–¶</button>
                </div>
            </div>
        </div>
    </div>

    <div class="ribbon">ğŸ§  ØªÙ‚Ø¯Ù‘Ù…Ùƒ Ù…Ø­ÙÙˆØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§</div>

    <!-- Ù…Ø³ØªÙˆÙŠØ§Øª -->
    <dialog id="levelsDlg">
        <div class="modal-head">
            <strong>Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨</strong>
            <button class="btn secondary" onclick="levelsDlg.close()">Ø¥ØºÙ„Ø§Ù‚</button>
        </div>
        <div class="modal-body">
            <div class="level-selector" id="levelSelector">
                <div class="level-card" data-level="1">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø£ÙˆÙ„</div>
                    <div class="level-desc">ÙƒÙ„Ù…Ø§Øª Ø¨Ø³ÙŠØ·Ø© Ù…Ù† 3â€“4 Ø£Ø­Ø±Ù</div>
                </div>
                <div class="level-card" data-level="2">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ø§Ù†ÙŠ</div>
                    <div class="level-desc">4â€“5 Ø£Ø­Ø±Ù Ù…ØªÙ†ÙˆØ¹Ø©</div>
                </div>
                <div class="level-card" data-level="3">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ø§Ù„Ø«</div>
                    <div class="level-desc">Ø£Ù†Ø´Ø·Ø© ÙŠÙˆÙ…ÙŠØ©</div>
                </div>
                <div class="level-card" data-level="4">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø±Ø§Ø¨Ø¹</div>
                    <div class="level-desc">Ù…Ù† Ø¯Ø±ÙˆØ³ Ø§Ù„Ù„ØºØ©</div>
                </div>
                <div class="level-card" data-level="5">
                    <div class="level-title">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø§Ù…Ø³</div>
                    <div class="level-desc">ØªØ­Ø¯Ù‘ÙŠ Ø§Ù„ÙƒÙ„Ù…Ø§Øª</div>
                </div>
            </div>
            <div class="action-bar">
                <div class="action-buttons">
                    <button class="btn secondary" id="btnClearLevelProgress">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ</button>
                    <button class="btn secondary" id="btnClearAllProgress">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙƒÙ„ Ø§Ù„ØªÙ‚Ø¯Ù…</button>
                </div>
            </div>
        </div>
    </dialog>

    <!-- ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‘Ù… -->
    <dialog id="teacherDlg">
        <div class="modal-head">
            <strong>ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù‘Ù… (Ø¥Ø¶Ø§ÙØ© ÙƒÙ„Ù…Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©)</strong>
            <button class="btn secondary" onclick="teacherDlg.close()">Ø¥ØºÙ„Ø§Ù‚</button>
        </div>
        <div class="modal-body">
            <div class="tiny">Ø£Ø¶Ù ÙƒÙ„Ù…Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© ÙˆØ³ØªÙØ­ÙØ¸ Ù…Ø­Ù„ÙŠÙ‹Ø§ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­.</div>
            <div class="grid">
                <div>
                    <label>Ø§Ù„ÙƒÙ„Ù…Ø§Øª (Ø§ÙØµÙ„ Ø¨ÙØ§ØµÙ„Ø©):</label>
                    <textarea id="tWords" rows="4" placeholder="Ù…Ø«Ø§Ù„: Ù‚Ù„Ù…ØŒ ÙƒØªØ§Ø¨ØŒ Ù…Ø¯Ø±Ø³Ø©"></textarea>
                </div>
                <div>
                    <label>Ø§Ù„Ù…Ø³ØªÙˆÙ‰:</label>
                    <select id="tLevel">
            <option value="1">1 (Ø¨Ø³ÙŠØ·)</option>
            <option value="2">2 (Ù…ØªÙ†ÙˆØ¹)</option>
            <option value="3">3 (Ø£Ù†Ø´Ø·Ø©)</option>
            <option value="4">4 (Ø¯Ø±ÙˆØ³)</option>
            <option value="5">5 (ØªØ­Ø¯Ù‘ÙŠ)</option>
          </select>
                </div>
            </div>
            <div style="margin-top:10px;">
                <label>Ù…Ù„Ø§Ø­Ø¸Ø§Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):</label>
                <input id="tNotes" placeholder="Ù…Ø«Ø§Ù„: ÙƒÙ„Ù…Ø§Øª Ù…Ù† Ø¯Ø±Ø³ Ø§Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª">
            </div>
            <div class="action-bar" style="margin-top:12px;">
                <div class="action-buttons">
                    <button class="btn" id="btnAddWords">Ø¥Ø¶Ø§ÙØ© â•</button>
                    <button class="btn bad" id="btnClearAll">Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª ğŸ—‘ï¸</button>
                </div>
            </div>
        </div>
    </dialog>

    <script>
        (() => {

            /* ===== Ø¨ÙŠØ§Ù†Ø§Øª Ø§ÙØªØ±Ø§Ø¶ÙŠØ© ===== */
            const builtInBank = {
                1: [{
                    words: ["Ù‚Ù„Ù…", "ÙƒØªØ§Ø¨", "Ø¨Ø§Ø¨", "Ø¹Ù„Ù…", "ÙˆÙ„Ø¯", "Ø¨Ù†Øª"],
                    notes: "ÙƒÙ„Ù…Ø§Øª Ù…Ù† Ø§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ù…Ø¯Ø±Ø³ÙŠØ©"
                }, {
                    words: ["Ø£Ø³Ø¯", "Ù†Ù…Ø±", "ÙÙŠÙ„", "Ù‚Ø±Ø¯", "Ø¯Ø¨", "Ø¬Ù…Ù„"],
                    notes: "Ø£Ø³Ù…Ø§Ø¡ Ø­ÙŠÙˆØ§Ù†Ø§Øª"
                }, {
                    words: ["Ù…Ø§Ø¡", "ØªÙ…Ø±", "Ø¹Ù†Ø¨", "Ù…ÙˆØ²", "ØªÙŠÙ†", "Ø®Ø¨Ø²"],
                    notes: "Ø·Ø¹Ø§Ù… ÙˆØ´Ø±Ø§Ø¨"
                }],
                2: [{
                    words: ["Ù…Ø¯Ø±Ø³Ø©", "Ù…Ø¹Ù„Ù…", "Ø·Ø§Ù„Ø¨", "Ø¯ÙØªØ±", "ÙƒØ±Ø³ÙŠ", "ÙØµÙ„"],
                    notes: "Ù…Ù† Ø§Ù„Ù…Ø¯Ø±Ø³Ø©"
                }, {
                    words: ["Ø¨ÙŠØª", "ØºØ±ÙØ©", "Ù…Ø·Ø¨Ø®", "Ø­Ù…Ø§Ù…", "Ø³Ø±ÙŠØ±", "Ø¨Ø§Ø¨"],
                    notes: "Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ù†Ø²Ù„"
                }, {
                    words: ["Ø³ÙŠØ§Ø±Ø©", "Ø¯Ø±Ø§Ø¬Ø©", "Ø·Ø§Ø¦Ø±Ø©", "Ù‚Ø·Ø§Ø±", "Ø¨Ø§Øµ", "Ø³ÙÙŠÙ†Ø©"],
                    notes: "ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„Ù†Ù‚Ù„"
                }],
                3: [{
                    words: ["ÙŠÙ‚Ø±Ø£", "ÙŠÙƒØªØ¨", "ÙŠÙ„Ø¹Ø¨", "ÙŠØ£ÙƒÙ„", "ÙŠÙ†Ø§Ù…", "ÙŠØ¬Ø±ÙŠ"],
                    notes: "Ø£ÙØ¹Ø§Ù„ ÙŠÙˆÙ…ÙŠØ©"
                }, {
                    words: ["ØµØ¨Ø§Ø­", "Ù…Ø³Ø§Ø¡", "Ø¸Ù‡Ø±", "Ù„ÙŠÙ„", "Ù†Ù‡Ø§Ø±", "ØºØ±ÙˆØ¨"],
                    notes: "Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ÙŠÙˆÙ…"
                }, {
                    words: ["Ø£Ø­Ù…Ø±", "Ø£Ø²Ø±Ù‚", "Ø£ØµÙØ±", "Ø£Ø®Ø¶Ø±", "Ø£Ø³ÙˆØ¯", "Ø£Ø¨ÙŠØ¶"],
                    notes: "Ø§Ù„Ø£Ù„ÙˆØ§Ù†"
                }],
                4: [{
                    words: ["Ø­Ø¯ÙŠÙ‚Ø©", "Ù…Ø²Ø±Ø¹Ø©", "Ø´Ø¬Ø±Ø©", "Ø²Ù‡Ø±Ø©", "Ø¹ØµÙÙˆØ±", "ÙØ±Ø§Ø´Ø©"],
                    notes: "Ù…Ù† Ø§Ù„Ø·Ø¨ÙŠØ¹Ø©"
                }, {
                    words: ["Ø§Ù„Ù…Ø¹Ù„Ù…", "Ø§Ù„ØªÙ„Ù…ÙŠØ°", "Ø§Ù„Ù…Ø¯Ø±Ø³Ø©", "Ø§Ù„ÙƒØªØ§Ø¨", "Ø§Ù„Ù‚Ù„Ù…", "Ø§Ù„Ø³Ø¨ÙˆØ±Ø©"],
                    notes: "Ù…Ø¹ (Ø§Ù„) Ø§Ù„ØªØ¹Ø±ÙŠÙ"
                }, {
                    words: ["Ø±Ø³Ø§Ù„Ø©", "Ù‚ØµØ©", "Ø­ÙƒØ§ÙŠØ©", "ÙƒÙ„Ù…Ø©", "Ø¬Ù…Ù„Ø©", "Ø­Ø±Ù"],
                    notes: "Ø¹Ù† Ø§Ù„Ù„ØºØ©"
                }],
                5: [{
                    words: ["Ù…Ø³Ø¬Ø¯", "Ù…Ø¯Ø±Ø³Ø©", "Ù…Ø³ØªØ´ÙÙ‰", "Ù…ØªØ­Ù", "Ù…ÙƒØªØ¨Ø©", "Ù…ØªÙ†Ø²Ù‡"],
                    notes: "Ø£Ù…Ø§ÙƒÙ† Ø¹Ø§Ù…Ø©"
                }, {
                    words: ["ØµØ¯ÙŠÙ‚", "Ø£Ø®ÙŠ", "Ø£Ù…ÙŠ", "Ø£Ø¨ÙŠ", "Ø¬Ø¯ÙŠ", "Ø¹Ù…ÙŠ"],
                    notes: "Ø§Ù„Ø£Ø³Ø±Ø©"
                }, {
                    words: ["Ù†Ø¸ÙŠÙ", "Ø¬Ù…ÙŠÙ„", "ÙƒØ¨ÙŠØ±", "ØµØºÙŠØ±", "Ø·ÙˆÙŠÙ„", "Ù‚ØµÙŠØ±"],
                    notes: "ØµÙØ§Øª"
                }]
            };

            /* ===== ØªØ®Ø²ÙŠÙ† ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‘Ù… ===== */
            const teacherKey = "wf_teacher_words_v1";
            const loadTeacherWords = () => {
                try {
                    return JSON.parse(localStorage.getItem(teacherKey) || "{}")
                } catch {
                    return {}
                }
            };
            const saveTeacherWords = (d) => localStorage.setItem(teacherKey, JSON.stringify(d || {}));

            function getFullBank() {
                const t = loadTeacherWords();
                const m = {
                    1: [...builtInBank[1]],
                    2: [...builtInBank[2]],
                    3: [...builtInBank[3]],
                    4: [...builtInBank[4]],
                    5: [...builtInBank[5]]
                };
                for (const lvl of[1, 2, 3, 4, 5])
                    if (t[lvl]) m[lvl].push(...t[lvl]);
                return m;
            }

            /* ===== Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ===== */
            const stateKey = "wf_state_v1";

            function loadState() {
                try {
                    return JSON.parse(localStorage.getItem(stateKey)) || {
                        level: 1,
                        score: 0,
                        done: {},
                        currentPuzzle: 0
                    }
                } catch {
                    return {
                        level: 1,
                        score: 0,
                        done: {},
                        currentPuzzle: 0
                    }
                }
            }
            const state = loadState();
            const saveState = () => localStorage.setItem(stateKey, JSON.stringify(state));

            /* Ø¹Ù†Ø§ØµØ± */
            const el = {
                levelNow: document.getElementById("levelNow"),
                scoreNow: document.getElementById("scoreNow"),
                instructionText: document.getElementById("instructionText"),
                wordsFound: document.getElementById("wordsFound"),
                totalWords: document.getElementById("totalWords"),
                gameGrid: document.getElementById("gameGrid"),
                wordList: document.getElementById("wordList"),
                result: document.getElementById("result"),
                btnHint: document.getElementById("btnHint"),
                btnReset: document.getElementById("btnReset"),
                btnResetLevel: document.getElementById("btnResetLevel"),
                btnNext: document.getElementById("btnNext"),
                progress: document.getElementById("progress"),
                btnTeacher: document.getElementById("btnTeacher"),
                btnLevels: document.getElementById("btnLevels"),
                teacherDlg: document.getElementById("teacherDlg"),
                levelsDlg: document.getElementById("levelsDlg"),
                levelSelector: document.getElementById("levelSelector"),
                btnClearLevelProgress: document.getElementById("btnClearLevelProgress"),
                btnClearAllProgress: document.getElementById("btnClearAllProgress"),
                tWords: document.getElementById("tWords"),
                tLevel: document.getElementById("tLevel"),
                tNotes: document.getElementById("tNotes"),
                btnAddWords: document.getElementById("btnAddWords"),
                btnClearAll: document.getElementById("btnClearAll"),
            };

            /* ===== ØµÙˆØªÙŠØ§Øª: Ù…ØªÙˆØ§ÙÙ‚Ø© Ù…Ø¹ Ø§Ù„Ø¬ÙˆØ§Ù„ ===== */
            const ctx = new(window.AudioContext || window.webkitAudioContext)();

            function ensureAudio() {
                if (ctx && ctx.state !== 'running') {
                    ctx.resume().catch(() => {});
                }
            }
            ['pointerdown', 'touchstart', 'keydown', 'click'].forEach(e => window.addEventListener(e, () => ensureAudio(), {
                once: true,
                passive: true
            }));
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') ensureAudio();
            });

            function beep(freq = 880, ms = 120, type = "sine", vol = .03) {
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = type;
                o.frequency.value = freq;
                g.gain.value = vol;
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                setTimeout(() => o.stop(), ms);
            }

            const rand = arr => arr[Math.floor(Math.random() * arr.length)];

            /* ===== Ù…ØªØºÙŠÙ‘Ø±Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ© ===== */
            let gridSize = 8,
                grid = [],
                words = [],
                foundWords = [],
                selectedCells = [],
                currentDirection = null;
            let placedHoriz = 0,
                placedVert = 0;
            const COLORS = ['#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'];
            const wordColors = {};

            if (typeof window.CSS === 'undefined') window.CSS = {};
            if (typeof window.CSS.escape !== 'function') {
                window.CSS.escape = s => s.replace(/[^a-zA-Z0-9_\u0600-\u06FF-]/g, '\\$&');
            }

            function createGrid(size) {
                gridSize = size;
                grid = [];
                for (let i = 0; i < size; i++) {
                    grid[i] = [];
                    for (let j = 0; j < size; j++) grid[i][j] = '';
                }
            }

            function gridSizeForLevel(level) {
                switch (level) {
                    case 1:
                        return 5;
                    case 2:
                        return 6;
                    case 3:
                        return 7;
                    case 4:
                        return 8;
                    default:
                        return 9;
                }
            }

            function renderGrid() {
                el.gameGrid.style.setProperty('--cols', gridSize);
                el.gameGrid.innerHTML = '';
                for (let i = 0; i < gridSize; i++)
                    for (let j = 0; j < gridSize; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.textContent = grid[i][j] || '';
                        cell.addEventListener('mousedown', () => startSelection(i, j));
                        cell.addEventListener('mouseover', () => continueSelection(i, j));
                        cell.addEventListener('touchstart', e => {
                            e.preventDefault();
                            startSelection(i, j);
                        });
                        cell.addEventListener('touchmove', e => {
                            e.preventDefault();
                            const t = e.touches[0];
                            const at = document.elementFromPoint(t.clientX, t.clientY);
                            if (at && at.classList.contains('grid-cell')) {
                                continueSelection(parseInt(at.dataset.row), parseInt(at.dataset.col));
                            }
                        });
                        el.gameGrid.appendChild(cell);
                    }
                document.addEventListener('mouseup', endSelection, {
                    passive: true
                });
                document.addEventListener('touchend', endSelection, {
                    passive: true
                });
            }

            function renderWordList() {
                el.wordList.innerHTML = '';
                words.forEach(w => {
                    const d = document.createElement('div');
                    d.className = 'word-item' + (foundWords.includes(w) ? ' found' : '');
                    d.textContent = w;
                    d.dataset.word = w;
                    if (foundWords.includes(w) && wordColors[w]) {
                        d.style.color = wordColors[w];
                        d.style.borderColor = wordColors[w];
                        d.style.background = '#fff';
                    }
                    el.wordList.appendChild(d);
                });
                el.wordsFound.textContent = foundWords.length;
                el.totalWords.textContent = words.length;
            }

            function validateWordPlacement() {
                let attempts = 0,
                    max = 6;
                while (attempts < max) {
                    placedHoriz = 0;
                    placedVert = 0;
                    createGrid(gridSize);
                    let ok = true;
                    for (const w of words) {
                        if (!placeWord(w)) {
                            ok = false;
                            break;
                        }
                    }
                    if (ok) return true;
                    attempts++;
                }
                return false;
            }

            function placeWord(word) {
                const horizontal = [
                        [0, 1],
                        [0, -1]
                    ],
                    vertical = [
                        [1, 0],
                        [-1, 0]
                    ];
                const preferH = placedHoriz <= placedVert,
                    groups = preferH ? [horizontal, vertical] : [vertical, horizontal];
                for (const group of groups) {
                    const dirs = group.slice().sort(() => Math.random() - .5);
                    for (const [dy, dx] of dirs) {
                        for (let a = 0; a < 60; a++) {
                            const r = Math.floor(Math.random() * gridSize),
                                c = Math.floor(Math.random() * gridSize);
                            if (canPlaceWord(word, r, c, dy, dx)) {
                                for (let i = 0; i < word.length; i++) grid[r + i * dy][c + i * dx] = word[i];
                                if (dy === 0) placedHoriz++;
                                else placedVert++;
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function canPlaceWord(word, row, col, dy, dx) {
                for (let i = 0; i < word.length; i++) {
                    const r = row + i * dy,
                        c = col + i * dx;
                    if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) return false;
                    if (grid[r][c] && grid[r][c] !== word[i]) return false;
                }
                return true;
            }

            function fillRandomLetters() {
                const letters = "Ø£Ø¨ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹ØºÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙŠ";
                for (let i = 0; i < gridSize; i++)
                    for (let j = 0; j < gridSize; j++)
                        if (!grid[i][j]) grid[i][j] = letters[Math.floor(Math.random() * letters.length)];
            }

            function startSelection(row, col) {
                clearSelection();
                selectedCells.push({
                    row,
                    col
                });
                updateSelectedCells();
                currentDirection = null;
            }

            function continueSelection(row, col) {
                if (!selectedCells.length) return;
                if (selectedCells.some(c => c.row === row && c.col === col)) return;
                const first = selectedCells[0],
                    last = selectedCells[selectedCells.length - 1];
                if (selectedCells.length === 1) {
                    if (row === first.row) currentDirection = {
                        dy: 0,
                        dx: Math.sign(col - first.col)
                    };
                    else if (col === first.col) currentDirection = {
                        dy: Math.sign(row - first.row),
                        dx: 0
                    };
                    else return;
                } else {
                    const er = last.row + currentDirection.dy,
                        ec = last.col + currentDirection.dx;
                    if (row !== er || col !== ec) return;
                }
                selectedCells.push({
                    row,
                    col
                });
                updateSelectedCells();
            }

            function endSelection() {
                if (!selectedCells.length) return;
                const selectedWord = selectedCells.map(c => grid[c.row][c.col]).join('');
                if (words.includes(selectedWord) && !foundWords.includes(selectedWord)) {
                    foundWords.push(selectedWord);
                    const idx = Object.keys(wordColors).length % COLORS.length,
                        color = wordColors[selectedWord] || (wordColors[selectedWord] = COLORS[idx]);
                    markCellsAsCorrect(color);
                    renderWordList();
                    const item = document.querySelector(`[data-word="${CSS.escape(selectedWord)}"]`);
                    if (item) {
                        item.classList.add('found');
                        item.style.color = color;
                        item.style.border = `1px solid ${color}`;
                        item.style.background = '#fff';
                    }
                    beep(1200, 120, "square", .03);
                    state.score += 10;
                    el.scoreNow.textContent = state.score;
                    saveState();
                    if (foundWords.length === words.length) puzzleCompleted();
                } else {
                    beep(200, 150, "sawtooth", .03);
                    clearSelection();
                }
                selectedCells = [];
                currentDirection = null;
            }

            function updateSelectedCells() {
                document.querySelectorAll('.grid-cell.selected').forEach(c => {
                    if (!c.classList.contains('correct')) c.classList.remove('selected');
                });
                selectedCells.forEach(({
                    row,
                    col
                }) => {
                    const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
                    if (cell && !cell.classList.contains('correct')) cell.classList.add('selected');
                });
            }

            function markCellsAsCorrect(color = '#4caf50') {
                selectedCells.forEach(({
                    row,
                    col
                }) => {
                    const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                        cell.classList.remove('selected');
                        cell.classList.add('correct');
                        cell.style.borderColor = color;
                        cell.style.color = color;
                        cell.style.backgroundColor = '#fff';
                    }
                });
            }

            function clearSelection() {
                document.querySelectorAll('.grid-cell.selected').forEach(c => {
                    if (!c.classList.contains('correct')) c.classList.remove('selected');
                });
                selectedCells = [];
            }

            function useHint() {
                const remain = words.filter(w => !foundWords.includes(w));
                if (!remain.length) return;
                const w = rand(remain);
                for (let i = 0; i < gridSize; i++)
                    for (let j = 0; j < gridSize; j++) {
                        const dirs = [
                            [0, 1],
                            [0, -1],
                            [1, 0],
                            [-1, 0]
                        ];
                        for (const [dy, dx] of dirs) {
                            if (checkWordAt(w, i, j, dy, dx)) {
                                flashWord(w, i, j, dy, dx);
                                return;
                            }
                        }
                    }
            }

            function checkWordAt(word, row, col, dy, dx) {
                if (row + dy * (word.length - 1) >= gridSize || row + dy * (word.length - 1) < 0) return false;
                if (col + dx * (word.length - 1) >= gridSize || col + dx * (word.length - 1) < 0) return false;
                for (let i = 0; i < word.length; i++) {
                    const r = row + i * dy,
                        c = col + i * dx;
                    if (grid[r][c] !== word[i]) return false;
                }
                return true;
            }

            function flashWord(word, row, col, dy, dx) {
                const color = wordColors[word] || '#ffd54f',
                    cells = [];
                for (let i = 0; i < word.length; i++) {
                    const r = row + i * dy,
                        c = col + i * dx;
                    const cell = document.querySelector(`.grid-cell[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cells.push(cell);
                        cell.style.outline = `3px solid ${color}`;
                    }
                }
                setTimeout(() => cells.forEach(c => c.style.outline = ''), 900);
                state.score = Math.max(0, state.score - 5);
                el.scoreNow.textContent = state.score;
                saveState();
            }

            function puzzleCompleted() {
                el.result.className = "result ok";
                el.result.textContent = "ğŸ‰ Ø£Ø­Ø³Ù†Øª! ÙˆØ¬Ø¯ØªÙ ÙƒÙ„ Ø§Ù„ÙƒÙ„Ù…Ø§Øª";
                el.result.style.display = "block";
                el.btnNext.disabled = false;
                state.score += 10;
                el.scoreNow.textContent = state.score;
                markPuzzleCompleted();
                confetti();
            }

            function confetti() {
                const n = 22;
                for (let i = 0; i < n; i++) {
                    const p = document.createElement('div');
                    p.style.cssText = `position:fixed;width:10px;height:10px;background:hsl(${Math.random()*360},90%,60%);inset-inline-start:${(Math.random()*80+10)}vw;inset-block-start:0;border-radius:2px;z-index:9999`;
                    document.body.appendChild(p);
                    p.animate([{
                        transform: 'translateY(0) rotate(0deg)'
                    }, {
                        transform: `translateY(80vh) rotate(${Math.random()*720-360}deg)`
                    }], {
                        duration: 1200 + Math.random() * 700,
                        easing: "cubic-bezier(.2,.7,.2,1)"
                    }).onfinish = () => p.remove();
                }
            }

            /* Ù…Ø³ØªÙˆÙŠØ§Øª + ØªÙ‚Ø¯Ù‘Ù… */
            function setupLevelSelector() {
                const cards = el.levelSelector.querySelectorAll('.level-card');
                cards.forEach(card => {
                    const level = parseInt(card.dataset.level);
                    card.addEventListener('click', () => {
                        cards.forEach(c => c.classList.remove('active'));
                        card.classList.add('active');
                        state.level = level;
                        state.currentPuzzle = 0;
                        saveState();
                        el.levelsDlg.close();
                        createNewPuzzle();
                    });
                    if (level === state.level) card.classList.add('active');
                });
            }

            function markPuzzleCompleted() {
                if (!state.done[state.level]) state.done[state.level] = [];
                const key = `${state.level}-${state.currentPuzzle}`;
                if (!state.done[state.level].includes(key)) state.done[state.level].push(key);
                saveState();
                updateProgress();
            }

            function nextPuzzle() {
                state.currentPuzzle++;
                const bank = getFullBank()[state.level];
                if (state.currentPuzzle >= bank.length) state.currentPuzzle = 0;
                saveState();
                createNewPuzzle();
            }

            function updateProgress() {
                const bank = getFullBank()[state.level];
                if (!bank || !bank.length) return;
                const total = bank.length;
                let completed = 0;
                if (state.done[state.level]) bank.forEach((_, i) => {
                    const k = `${state.level}-${i}`;
                    if (state.done[state.level].includes(k)) completed++;
                });
                const p = Math.round(100 * completed / total);
                el.progress.style.setProperty('--p', p + '%');
            }

            function getWordSet() {
                const bank = getFullBank()[state.level];
                if (!bank || !bank.length) return {
                    words: [],
                    notes: "Ù„Ø§ ØªÙˆØ¬Ø¯ ÙƒÙ„Ù…Ø§Øª"
                };
                if (state.currentPuzzle >= bank.length) state.currentPuzzle = 0;
                return bank[state.currentPuzzle];
            }

            /* Ø¥Ù†Ø´Ø§Ø¡ Ù„ØºØ² Ø¬Ø¯ÙŠØ¯ */
            function createNewPuzzle() {
                foundWords = [];
                selectedCells = [];
                currentDirection = null;
                gridSize = gridSizeForLevel(state.level);
                const ws = getWordSet();
                words = [...ws.words].sort((a, b) => b.length - a.length);
                el.instructionText.textContent = ws.notes || "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø£ÙÙ‚ÙŠØ§Ù‹ ÙˆØ¹Ù…ÙˆØ¯ÙŠØ§Ù‹";
                el.levelNow.textContent = state.level;
                el.scoreNow.textContent = state.score;
                const ok = validateWordPlacement();
                if (!ok) {
                    createGrid(gridSize);
                    placedHoriz = 0;
                    placedVert = 0;
                    words.forEach(w => placeWord(w));
                }
                fillRandomLetters();
                renderGrid();
                renderWordList();
                el.result.style.display = "none";
                el.btnNext.disabled = true;
                updateProgress();
            }

            /* Ø¨Ø¯Ø§ÙŠØ© */
            setupLevelSelector();
            createNewPuzzle();

            /* Ø£Ø²Ø±Ø§Ø± */
            el.btnHint.addEventListener("click", useHint);
            el.btnReset.addEventListener("click", () => {
                if (confirm("Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ØŸ")) {
                    state.level = 1;
                    state.score = 0;
                    state.currentPuzzle = 0;
                    saveState();
                    createNewPuzzle();
                }
            });
            el.btnResetLevel.addEventListener("click", () => {
                if (confirm("Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠØŸ")) createNewPuzzle();
            });
            el.btnNext.addEventListener("click", nextPuzzle);
            el.btnTeacher.addEventListener("click", () => el.teacherDlg.showModal());
            el.btnLevels.addEventListener("click", () => {
                setupLevelSelector();
                el.levelsDlg.showModal();
            });
            el.btnClearLevelProgress.addEventListener("click", () => {
                if (confirm(`Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ØªÙ‚Ø¯Ù… Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${state.level}ØŸ`)) {
                    if (state.done[state.level]) {
                        state.done[state.level] = [];
                        saveState();
                        alert("ØªÙ….");
                        el.levelsDlg.close();
                        createNewPuzzle();
                    }
                }
            });
            el.btnClearAllProgress.addEventListener("click", () => {
                if (confirm("Ù…Ø³Ø­ ÙƒÙ„ Ø§Ù„ØªÙ‚Ø¯Ù…ØŸ")) {
                    state.done = {};
                    state.score = 0;
                    saveState();
                    alert("ØªÙ….");
                    el.levelsDlg.close();
                    createNewPuzzle();
                }
            });
            el.btnAddWords.addEventListener("click", () => {
                const text = (el.tWords.value || "").trim();
                if (!text) {
                    alert("Ø£Ø¯Ø®Ù„ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø£ÙˆÙ„Ø§Ù‹");
                    return;
                }
                const list = text.split(/[,ØŒ]/).map(w => w.trim()).filter(Boolean);
                const lvl = parseInt(el.tLevel.value || "1");
                const notes = (el.tNotes.value || "").trim() || "ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‘Ù…";
                const data = loadTeacherWords();
                if (!data[lvl]) data[lvl] = [];
                data[lvl].push({
                    words: list,
                    notes
                });
                saveTeacherWords(data);
                el.tWords.value = "";
                el.tNotes.value = "";
                alert("Ø£ÙØ¶ÙŠÙØª âœ… Ø³ØªØ¸Ù‡Ø± ÙÙŠ Ø§Ù„Ù…Ø³ØªÙˆÙ‰.");
            });
            el.btnClearAll.addEventListener("click", () => {
                if (confirm("Ø­Ø°Ù ÙƒÙ„ ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‘Ù…ØŸ")) {
                    saveTeacherWords({});
                    alert("ØªÙ… Ø§Ù„Ø­Ø°Ù.");
                }
            });

        })();
    </script>
</body>

</html>
